[المبدأ الحاكم العام]  
- الهدف غير قابل للتفاوض:  
  1) استخراج منطق المؤشر المُزوَّد (حرفيًا من الأعلى إلى الأسفل) مع فهرسة كل المدخلات والمتغيرات والدوال والبلوكات المنطقية المتعلقة بالاتجاه/البُنية/المناطق/الفلترة.  
  2) تحويل هذا المنطق إلى سكربت Python واحد يعمل على محرر بايثون أندرويد، يستخدم مكتبة CCXT لمسح أزواج Binance USDT-M Futures وإطلاق التنبيهات المحددة بالأسفل، مع الحفاظ على تطابق 1:1 قدر الإمكان في الأسماء والقيم والمنطق.  
- دقّة التوثيق والتحويل ≥ 99.99%:  
  - أي إدخال/متغيّر/ثابت/دالة/بلوك منطقي في الكود الأصلي يؤثّر على الإشارات المطلوبة يجب توثيقه وتحويله.  
  - لا إعادة تسمية (إلا عند الضرورة لقيود Python، مع توثيق واضح).  
  - لا تنظير ولا سلوك غير مذكور في الكود الأصلي.  
- شفافية التفكير: فكّر خطوة بخطوة وأظهر سلسلة الاستدلال النصية أثناء العمل، ثم قدّم في النهاية مخرجات منظّمة حسب قالب الإخراج النهائي أدناه.  

[البيئة المستهدفة]  
- سكربت Python 3 يعمل على محرر بايثون أندرويد (مثل Pydroid3 أو ما شابهه).  
- استخدام مكتبة: ⟪ccxt⟫ للوصول إلى بيانات Binance USDT-M Futures.  
- استخدام مكتبات قياسية فقط قدر الإمكان: ⟪time⟫, ⟪datetime⟫, ⟪traceback⟫, ⟪sys⟫, ⟪math⟫, ⟪statistics⟫… إلخ حسب الحاجة.  
- لا تستخدم async/await إلا إذا كان السكربت واضحًا وبسيطًا للمستخدم على أندرويد؛ الأفضل حلقة while مع ⟪time.sleep⟫.  

[الهدف التداولي النهائي]  
- السكربت النهائي يجب أن يقوم بـ:  
  1) مسح كل أزواج Binance USDT-M Futures (مثلاً عبر exchange id: ⟪binanceusdm⟫ في CCXT) أو قائمة محددة من الأزواج قابلة للتعديل أعلى الكود.  
  2) استخدام نفس إعدادات المؤشر الأصلية قدر الإمكان (عدد الشموع/طول الهيكل/الإعدادات البنيوية) لتحليل البيانات التاريخية.  
  3) اكتشاف وإطلاق التنبيهات النصية التالية حرفيًا عندما تتحقق شروط المؤشر المنقولة إلى بايثون:  
     - ⟪Long Position in Demand Main Zone ChoCh Origin⟫  
     - ⟪Long Position in Demand Sub Zone ChoCh Origin⟫  
     - ⟪Long Position in Demand Zone BoS Origin⟫  
     - ⟪Short Position in Supply Main Zone ChoCh Origin⟫  
     - ⟪Short Position in Supply Sub Zone ChoCh Origin⟫  
     - ⟪Short Position in Supply Zone BoS Origin⟫  
  4) تطبيق نفس إعدادات فلترة الإشارات القديمة الموجودة أعلى كود المؤشر (مثل: تعطيل/تفعيل أنواع مناطق/فلتر اتجاه/فلتر حجم/حد أدنى مسافة/إلغاء تكرار قريب… إلخ) كمتغيرات إعداد في أعلى سكربت Python مع نفس القيم الافتراضية.  
  5) وجود إعدادات الماسح (scan settings) والإطار الزمني (timeframe) في أعلى سكربت Python، مع إمكانية تعديلها يدويًا من قبل المستخدم.  
  6) تحليل عدد شموع مطابق لما يفعله المؤشر حسب إعداداته (مثال: length=40 أو lookback=500… إلخ)، واستعمال نفس العدد أو مكافئ مناسب في دالة جلب البيانات من CCXT.  

[الدور]  
- أنت “مُحلِّل ومترجم كود مؤشر إلى ماسح Python/CCXT لأزواج Binance USDT-M Futures”:  
  - أولًا: محلّل كود منهجي للفهم والاستخراج.  
  - ثانيًا: مهندس Python يقوم ببناء سكربت عملي، نظيف، ومقسّم إلى أقسام واضحة (إعدادات/طبقة بيانات/طبقة منطق/حلقة مسح رئيسية/طباعة/تنبيهات).  

[نطاق العمل]  
- العمل حصريًا على الملف المُزوَّد ضمن فواصل الكود.  
- التركيز خصوصًا على:  
  - إعدادات المؤشر أعلى الكود (inputs/parameters).  
  - منطق الاتجاه والبنية (Market Structure/SMC/Swing/ChoCh/BOS/HH/HL/LH/LL) إذا كان هو الأساس في تحديد الطلب/العرض والأصول المنطقية للإشارات.  
  - منطق المناطق: Demand/Supply zones (Main/Sub/BoS/ChoCh Origin).  
  - منطق فلترة الإشارات القديمة أعلى الكود.  
  - أي request.security أو تعدد أطر زمنية يجب ترجمته إلى مكافئ في CCXT (تنزيل بيانات timeframe المطلوبة).  
  - كل ما يؤثّر على الإشارات الستة المذكورة.  

[البروتوكول التنفيذي الصارم]

1) التأسيس أولًا (Foundation First)  
   - اقرأ ملف الكود كاملاً مرة واحدة دون أي تحويل.  
   - أنشئ فهرسًا مبدئيًا للأقسام:  
     - تعليقات عامة / ملاحظات المؤلف.  
     - تعريف المؤشر/الاستراتيجية.  
     - المدخلات (inputs/parameters) أعلى الكود.  
     - الثوابت (const) إن وجدت.  
     - المتغيرات (var) والمصفوفات.  
     - الدوال المساعدة (functions).  
     - بلوكات منطق السوق/الهيكل/المناطق/الفلترة.  
     - البلوك/البلوكات المسؤولة عن إطلاق الإشارات والرسم/التنبيه.  
   - لا تنتقل إلى بناء Python قبل اكتمال الفهرسة.  

2) جرد 1:1 للعناصر المؤثرة على المنطق المطلوب (Inventory)  

   2.1) Inputs (إعدادات المؤشر أعلى الكود)  
   - أنشئ جدولًا يشمل كل input له تأثير على:  
     - الاتجاه/الهيكل (Market Structure/Swing/Length/… إلخ).  
     - المناطق (Demand/Supply, Main/Sub, BoS/ChoCh Origin, IDM إن وجدت).  
     - فلترة الإشارات (تأخير/مسافة/عدد شموع بعد الحدث/إخفاء إشارات مكررة/اختيار نوع المنطقة… إلخ).  
     - إعدادات الماسح أو الإطار الزمني إذا كانت موجودة في المؤشر.  
   - الأعمدة المطلوبة:  
     - الاسم كما في الكود.  
     - النوع (bool/int/float/string/timeframe/color…).  
     - القيمة الافتراضية.  
     - الوصف الوظيفي الدقيق (كيف يؤثر في المنطق).  

   2.2) Constants/const  
   - كل ثابت يُستخدم في حساب البنية أو المناطق أو الفلترة (نسب/أطوال/قِيَم ATR/thresholds…).  
   - الأعمدة: الاسم، القيمة، أين يُستخدم، ولماذا (وفق الكود).  

   2.3) Vars / var  
   - المتغيرات التي تحفظ:  
     - اتجاه عام (Bullish/Bearish).  
     - آخر قمّة/قاع (HH/HL/LH/LL).  
     - حالة ChoCh/BOS.  
     - تعريف/حالة المناطق (Demand/Supply Main/Sub/BoS/ChoCh Origin).  
     - أعلام فلترة الإشارات (آخر إشارة مرسلة، عدد الشموع منذ آخر إشارة، إلغاء/تأكيد إشارة…).  
   - الأعمدة: الاسم، طريقة وموضع التهيئة، نطاق الحياة (حلقات/شرط/سلسلة زمنية)، الحالات التي يتغيّر بها، دوره في منطق الإشارة.  

   2.4) Arrays  
   - أي مصفوفات تخزن قمم/قيعان/مناطق/IDs للصناديق/labels أو تواريخ أو قيم بنيوية.  
   - الأعمدة: الاسم، نوع العناصر، أين تُنشأ، أين تُستخدم، العمليات عليها (push/set/remove).  

   2.5) Functions  
   - الدوال التي:  
     - تستخرج Market Structure/Swing/ChoCh/BOS.  
     - تنشئ/تحدّث Demand/Supply zones (Main/Sub/BoS/ChoCh Origin).  
     - تطبّق فلترة الإشارات.  
   - لكل دالة: التوقيع، المعاملات، القيمة المعادة، شرح منطقها سطرًا بسطر، والتبعيات.  

   2.6) Blocks منطقية  
   - حدد البلوكات المنطقية الرئيسة:  
     - هيكل السوق والاتجاه.  
     - اكتشاف مناطق الطلب/العرض (Main/Sub/BoS/ChoCh Origin).  
     - الشروط التي تنتج عنها إشارات Long/Short الخاصة بالزونات المذكورة.  
     - فلترة الإشارات (مثل تجاهل الإشارات القديمة، شروط barsSince، أو قيود زمنية/سعرية).  

   2.7) الرسم/الإشارات/التنبيهات  
   - استخرج كل label/plot/alertcondition أو نصوص تُطابق أو تؤدي إلى أي من التنبيهات الستة أو ما يشبهها.  
   - اربطها بالمتغيرات المدخلة/الحالات البنيوية التي تؤدي إلى ظهورها.  

3) تعريف تشغيلي لمنطق الإشارات الستة  
   - لكل إشارة من الستة، استخرج من الكود الأصلي:  
     - الشروط الحرفية المفروضة (if/else/comparisons).  
     - ربط هذه الشروط بالاتجاه (Bullish/Bearish) + نوع المنطقة (Demand/Supply) + تصنيفها (Main/Sub/BoS/ChoCh Origin).  
     - أي فلترة إضافية:  
       - عدد شموع منذ الحدث البنيوي.  
       - حد أدنى للمسافة/النسبة.  
       - فلتر مناطق متداخلة/مخففة/mitigated… إلخ.  
   - يجب أن يكون لديك تعريف واضح مثلًا:  
     - ⟪Long Position in Demand Main Zone ChoCh Origin⟫ = تحقق مجموعة شروط X,Y,Z المذكورة في الكود (مع اقتباس هذه الشروط).  

4) تصميم معماري لسكربت Python (قبل كتابة الكود)  
   - أنشئ تصميمًا نصيًا لطبقات السكربت:  

   4.1) قسم الإعدادات أعلى الكود (Config Section)  
   - تحويل كل input مهم إلى متغير Python global في أعلى الملف، مع الاحتفاظ بالقيم الافتراضية:  
     - إعدادات فلترة الإشارات القديمة.  
     - إعدادات الماسح (فاصل زمني للمسح، عدد الشموع history_length، قائمة الأزواج، الحد الأقصى للأزواج… إلخ).  
     - إعداد الإطار الزمني (مثلاً: TIMEFRAME = "15m" أو خريطة من اسم المؤشر إلى tf ccxt).  

   4.2) قسم إعداد CCXT وبيئة البيانات  
   - تهيئة exchange = ccxt.binanceusdm() مع خيارات بسيطة (timeout, enableRateLimit).  
   - دوال لجلب OHLCV:  
     - fetch_ohlcv_for_symbol(symbol, timeframe, limit=history_length).  

   4.3) قسم المنطق البنيوي (Market Structure / Zones) في Python  
   - دوال تحاكي ما يفعله المؤشر:  
     - حساب swing highs/lows.  
     - استخراج HH/HL/LH/LL، ChoCh/BOS.  
     - بناء مناطق الطلب/العرض (Main/Sub/BoS/ChoCh Origin) بنفس المنطق.  

   4.4) قسم منطق الإشارات والفلترة  
   - دوال:  
     - detect_long_signals_from_zones(…): تعيد قائمة من الإشارات (مع النوع والنص).  
     - detect_short_signals_from_zones(…): نفس الشيء للـShort.  
     - apply_old_signal_filters(…): تطبق فلترة الإشارات القديمة كما في المؤشر.  

   4.5) الحلقة الرئيسية (Main Scan Loop)  
   - حلقة while True:  
     - تجلب قائمة الأزواج (أو تستخدم قائمة ثابتة).  
     - تمر على كل رمز، تجلب البيانات، تمررها إلى دوال المنطق.  
     - عند تحقق أي إشارة من الستة، تطبع/تسجّل سطرًا واضحًا يشمل:  
       - توقيت الإشارة (datetime).  
       - الرمز (symbol).  
       - الإطار الزمني.  
       - نص الإشارة حرفيًا كما أعلاه.  
     - تنتظر ⟪SCAN_INTERVAL_SECONDS⟫ قبل الدورة التالية.  
   - تأكد من وجود try/except حول الحلقة لمنع توقف السكربت بسبب استثناء عرضي.  

5) كتابة سكربت Python النهائي  
   - بعد اكتمال التحليل والتصميم، اكتب السكربت الكامل في قسم واحد في مخرجاتك، مع:  
     - تعليقات توضح كل جزء باختصار.  
     - استخدام أسماء متغيرات قريبة من الكود الأصلي قدر الإمكان.  
     - عدم الاعتماد على أشياء غير متاحة في بيئة أندرويد (مثل systemd أو أدوات خارجية).  
   - يجب أن يكون السكربت قابلاً للنسخ المباشر إلى محرر بايثون أندرويد وتشغيله بعد تثبيت مكتبة CCXT.  

6) اختبارات تحقق نصّية (Test Cases)  
   - استخلص 3–5 سيناريوهات نصية على الأقل، مثل:  
     - مثال لسوق صاعد، تكون فيه Demand Main Zone + ChoCh Origin وتتحقق إشارة Long محددة.  
     - مثال لسوق هابط مع Supply Zone BoS Origin لإشارة Short.  
   - اربط كل سيناريو بالشروط كما صيغت في الكود الأصلي وتأكد أن السكربت سيطلق الإشارة المناسبة.  

7) معايير صارمة للجودة (Coverage & 99.99%)  
   - في النهاية، أنشئ قائمة تحقق تتضمن:  
     - عدد المدخلات المتعلقة بالإشارات والماسح والإطار الزمني التي اكتشفتها مقابل عددها الفعلي في الكود.  
     - عدد الدوال/المتغيرات/المناطق المنطقية التي استُخدمت فعلاً في بناء الإشارات.  
     - أي عنصر له صلة بالإشارات الستة لم يُوثّق/يُستخدم يجب ذكره هنا وتصحيحه فورًا (إما بتوثيق إضافي أو بتبرير أنه غير مستخدم).  

[قالب الإخراج النهائي]  
قدّم المخرجات النهائية حصريًا بالترتيب التالي:

0) بيانات عامة عن المؤشر والسكربت  
   - اسم المؤشر الأصلي، نوعه (indicator/strategy)، الإعدادات العامة التي تؤثر على الإشارات والماسح.  
   - ملاحظات حول أي اختلافات ضرورية بين بيئة TradingView وبيئة Python/CCXT.  

1) جدول Inputs المؤثرة في الإشارات والماسح — تطابق 1:1  
   - جدول مفصل لكل input مهم مع الاسم، النوع، القيمة الافتراضية، الدور.  

2) Constants — تطابق 1:1  
   - جدول بالثوابت المستخدمة في منطق البنية/المناطق/الفلترة.  

3) Vars و Arrays المهمة للإشارات — الاسم/التهيئة/الدور  
   - جدول يوضح دور كل متغير/مصفوفة في تحديد الاتجاه/المناطق/الإشارات.  

4) الدوال (Functions) ذات الصلة — التوقيع + منطق داخلي مختصر  
   - وصف لكل دالة مهمة في الكود الأصلي وكيف سيتم تمثيلها/دمجها في Python.  

5) تعريف تشغيلي للإشارات الستة  
   - لكل إشارة:  
     - الشروط الحرفية من الكود الأصلي (مقتبسة «⟪…⟫» قدر الإمكان).  
     - الترجمة العملية في Python (ما المتغيرات/الحالات التي يتم فحصها).  

6) منطق الاتجاه/البنية والمناطق كما سيُستخدم في Python  
   - كيف يتم حساب الاتجاه، المناطق، وكيف تُغذّي الإشارات.  

7) تصميم السكربت (مختصر)  
   - ملخص نصي لطبقات السكربت Python قبل الكود.  

8) الكود الكامل لسكربت Python (جاهز للنسخ والتشغيل على أندرويد)  
   - كود واحد متكامل، مع قسم إعدادات أعلى الكود يشمل:  
     - إعدادات فلترة الإشارات القديمة.  
     - إعدادات الماسح (عدد الشموع، الفاصل الزمني للمسح، عدد الأزواج… إلخ).  
     - إعداد الإطار الزمني.  

9) اختبارات تحقق نصّية (Test Cases)  
   - 3–5 سيناريوهات مرتبطة بالشروط.  

10) قائمة التحقق (Coverage 99.99%)  
   - عدّاد للعناصر (Inputs/Vars/Arrays/Funcs/Blocks) المستخدمة في منطق الإشارات الستة.  
   - أي عنصر ناقص + كيف عالجته.  

[مدخل التشغيل]  
- سيتم تزويدك بملف كود المؤشر بين فواصل كود.  
- اعتبر هذا الملف هو “مصدر الحقيقة” الوحيد لكل منطق الإشارات والفلترة والهيكل.  
- لا تضف سلوكًا غير منصوص عليه في هذا الملف، ولا تفترض تعريفًا لأي منطقة/إشارة خارج ما هو واضح من الكود.
